[
  
    {
        
          "title"    : "Prototyypit",
          "category" : "design",
          "tags"     : "",
          "url"      : "/practices/design/prototyypit/",
          "date"     : "2016-12-09 19:08:15 +0200",
          "content"  : ""
        
    } ,
  
    {
        
          "title"    : "Testaus",
          "category" : "design",
          "tags"     : "",
          "url"      : "/practices/design/testaus/",
          "date"     : "2016-12-09 19:08:08 +0200",
          "content"  : ""
        
    } ,
  
    {
        
          "title"    : "Versionhallinta",
          "category" : "tyokalut",
          "tags"     : "",
          "url"      : "/practices/tyokalut/versionhallinta/",
          "date"     : "2016-12-09 19:03:45 +0200",
          "content"  : "Pääperiaatteet  Kirjoita koodi aina johonkin omaan featurebranchiin, muuhun kuin masteriin  Nimeä featurebranchit Jirataskin mukaan mikäli mahdollista.  Tagaa master branch kun on todettu, että toimiva liveytys on tehty. Kirjoita lyhyt kommentti tagaukseen, jossa liveytyksen syy, päivämäärä sekä versionumero.  Käytä tagauksen versionumerointiin SEMVER numerointia http://semver.org/ https://git-scm.com/book/en/v2/Git-Basics-Tagging  Kaikki branchit, joissa on uniikkia koodia tulee pushata originiin. Ei säilötä mitään koodia pelkästään lokaalissa gitissä.  Mikäli on tarve tehdä hotfix, tee oma hotfix branch masterista. Laita branchin nimeen HOTFIX-yyyy-mm-dd tai HOTFIX-Jira task (jos sellainen on)”. Kommentoi pushiin lyhyesti syy hotfiksille ja mitä on tehty.  staging branch mergetään master branchiin kun kaikki staging branchiin mergetyt feature branchit halutaan liveyttää.  Mikäli staging branchista ei voida liveyttää kaikkea, masteriin tai väliaikaiseen branchiin mergetään halutut feature branchit ja ko. branch testataan dev tai stage palvelimella.FeaturebranchitJokaista selkeää featurekokonaisuutta varten luodaan omat branchit joissa ko. featurea kehitetään.Lokaalit testausbranchitJokainen kehittäjä voi tehdä omia testibrancheja joihin voi mergetä featurebrancheja testimielessä. Nämä branchit ovat vain testausta varten, eikä niitä pushata originiin ellei ole erityistä tarvetta mm. testauksen siirtäminen toiselle henkilölle.StageTässä branchissa on versio joka on ajossa sellainen versio joka sisältää devaajien testaamia featureita joita asiakas haluaa pitää staging palvelimella.HotfixTämä branchi kloonataan masterista ja siihen tehdään suoraan tarvittava fiksaus. Hotfix voidaan deployata staging palvelimella ja testata siellä. Kun testaus on suoritettu staging palvelin palautetaan käyttämään stage branchia. Hotfix branch mergetään master branchiin ja depoloyataan uusi master branch live palvelimelle.Mastermaster brachissa on live palvelimella kulloinkin oleva versio.KehitysFeature brancheihin kehitetään yksittäisiä featureita omalla koneella ja ne pushataan originiin. Lokaaleja testausbrancheja käytetään devauksen tukena. Nämä branchit tulee poistaa käytön jälkeen.TestausKun on tehnyt featureita joita haluaa laittaa staging-palvelimelle, hakee staging branchin omalle koneelle, johon mergettää halutut feature branchit. Tämä branch testataan devi tai stage palvelimella projektista riippuen.Kun branchiin on tyytyväinen se mergetään staging branchiin. staging branchiin mergetään sellaisia feature brancheja, jotka devaaja on itse testannut ja asiakas haluaa staging palvelimelleCode reviewProjektin git-käytännöt asetetaan niin, että merge request on pakko tehdä, jos featuren haluaa asiakkaan nähtäväksi asti. Tämä taso vaihtelee projektin palvelin-/palvelu-arkkitehtuurin perusteella stagen ja tuotannon välillä.LiveytysJos todettu staging branch toimivaksi ja halutaan liveyttää se kokonaisuudessaan, mergetään se masterbranchiin ja deployataan.Jos halutaan liveyttää vain osa staging branchissa olevista feature brancheista, mergetään master branchiin ko. feature branchit.Workflow esimerkki Git-käskyilläEsimerkkiprojektiin v1.0.0 halutaan uusi ominaisuus, kehittäjä on saanut jiratehtävän TIL-123Kehittäjä hakee esimerkkiprojektin työasemalleen git clone git@mygitdomain.com:project/repository.gitKehittäjä luo featurebranchin git checkout -b TIL-123Kehittäjä koodaa uuden ominaisuuden ja tallentaa työnsä gitlabiingit add -Agit commit -m 'halutut ominaisuudet xyz'git push origin TIL-123Kehittäjä saa ominaisuuden valmiiksi ja yhdistää sen ```stage`` branchiin testaamista vartengit checkout stagegit merge TIL-123git push origin stageOminaisuus deployataan staging-palvelimelle, testataan ja asiakas hyväksyy sen.Kehittäjä yhdistää ominaisuuden master-branchiingit checkout mastergit merge TIL-123git push origin mastermaster-branch deployataan tuotantopalvelimelle onnistuneesti, se testataan ja hyväksytään. Kehittäjä tägää master-branchiin toimivan versiongit tag -a v1.1.0 -m 'julkaisu ominaisuuksilla xyz 2016-04-20'git push --follow-tagsRollbackitHuomataan, että esimerkkiprojektin liveytys ei olekaan hyvä, uusi ominaisuus bugaa pahasti.Kehittäjä palauttaa master-branchin versioon v1.0.0git reset --hard v1.0.0"
        
    } ,
  
    {
        
          "title"    : "Dokumentointi",
          "category" : "tyokalut",
          "tags"     : "",
          "url"      : "/practices/tyokalut/dokumentointi/",
          "date"     : "2016-12-09 18:30:54 +0200",
          "content"  : "WordPress-projektien dokumentointiWordPress-projekteissa projektin juureen luodaan README.md tiedosto, jossa kerrotaan projektin oleellisimmat asiat kehittäjälle paikallisen kehitysympäristön pystytykseen ja projektin stagelle ja tuotantoon viemiseen.Asiakokonaisuuksien dokumentointiProjektin juureen luodaan docs hakemisto, jonka alle dokumentoidaan omiin .md tiedostoihinsa projektin oleellisimmat tekniset kokonaisuudet ja asiat.Esim. tehty henkilöitä varten uusi Custom Post Type “henkilot” johon liittyy filtteröitävä listausnäkymä (sivupohja) sekä yksittäisen henkilön single näkymä. Tätä kokonaisuutta varten luodaan docs/henkilot.md johon kirjataan:  Henkilöt kokonaisuuden toiminnallisuus (esim. vaatimusmäärittelystä)  Sisältötyypissä käytetyt custom fieldit ja niihin liittyvät mahdolliset erityishuomiot  Filtteröinnin toteutustapa, esim. javascript-kirjasto  Tärkeimpien tiedostojen sijainnit  Erityiset muut lisähuomiot, esim. custom rewritetMinimissään jokaisesta asiakokonaisuudesta olisi dokumentoituna vähintään vaatimusmäärittelyn mukainen lopputulos ja poikkeukset tai jos vaatimusmäärittelyä ei ole niin lyhyt kuvaus toiminnallisuudesta.Koodin dokumentointiDokumentoidaan omat metodit PHPDoc standardin mukaan."
        
    } ,
  
    {
        
          "title"    : "Kehityksen työkalut",
          "category" : "tyokalut",
          "tags"     : "",
          "url"      : "/practices/tyokalut/kehitys/",
          "date"     : "2016-12-09 18:30:29 +0200",
          "content"  : "KoodieditoritGeniemillä käytetään pääosin koodieditorina Sublime Text 3 -editoria. Sublime on todettu vikkeläksi ja siihen saa monia eri lisäosia + integraatioita. Kaikkia kehittäjiä suositellaan pitämään editorinsa päivitettynä koko ajan, jotta ohjeet sekä lisäosien saatavuudet olisivat samat jokaiselle.Package ControlJos käytät sublimea, tulee siihen asentaa Package Control, jotta voita asentaa tarvittavat lisäosat.Sublime LinterKoodausstandardien käyttämisen varmistamiseksi Geniemillä tehdään kooditiedostojen tarkistus ennen tiedostojen lähettämistä versionhallintaan. Tämän tueksi tulee asentaa Sublimeen lisäosa nimeltä Sublime Linter ja siihen asianmukaiset linterit, jotka kertovat syntaksi- ja tyylivirheistä jo koodia kirjoittaessa. Geniemillä käytetään seuraavia lintereitä ja koodityylejä standardoivia lisäosia.  phpcs  jscs  scss  docblockrMuut editoritGeniemillä voi käyttää valitsemaansa tekstieditoria tai IDE:tä, mutta Sublimen käyttö on suositeltavaa ja yhteiset ohjeistukset on tehty Sublimea varten. Jos käytät toista editoria, tulee samat linterit ja syntaksin tarkistukset olla asennettu käyttämääsi työkaluun.WebpackProjektien resurssien kääntämiseen ja projektin buildaamiseen käytetään Geniemillä Webpack-työkalua. Geniemillä on Webpackia varten oma configuraatiotiedosto, jossa määritetään projektin resurssien kääntäminen ja ympäristökohtaiset asetukset. Webpackia suosimme Gulpin sijaan sen kasvavan suosion ja todetun helppokäyttöisyyden vuoksi. Webpack-konfiguraatiotiedostot ovat helppolukuisempia ja JS-tiedostojen importaus tapahtuu helposti. Webpackin käytöstä lisää löydät ohjeet-sivulta.PakettienhallintaGeniemillä käytetään kahta paketinhallintatyökalua; Composer-työkalua PHP-pakettien hallintaan ja NPM-työkalua muiden pakettien (JS ja tyylit) hallintaan. Kaikki resurssit, frameworkit, pluginit ja muut ulkoiset kirjastot ladataan sekä ylläpidetään projektissa näiden työkalujen kautta.FoundationGeniemillä käytetään projektien frameworkina Foundation 6:sta ja tämän tarjoamia lisäosia. Foundation on suosittu ja erittäin tuettu framework ja se sisältää kattavan määrän featureita projektien nopeaan aloittamiseen.VagrantToisena lokaalina kehitysympäristönä Geniemillä käytetään Vagrantia. Vagrant-ympäristö on käytössä vanhemmissa projekteissa. Kaikissa uusissa projekteissa suositaan kuitenkin Gdeviä sen paremmuuden vuoksi.CodekitEnnen Webpackin valitsemista käytettäväksi task runner -työkaluksi on Geniemillä käytetty Codekit-työkalua ja sen graafista käyttöliittymää. Codekitin käytön aloittaminen on ollut helppoa ja yksinkertaista ja asetukset on helppo ollut laittaa yhteiseen käyttöön. Kaikissa uusissa projekteissa suositaan kuitenkin Webpackia sen paremmuuden vuoksi.GithubGeniem käyttää githubia julkisiin projekteihinsa. Tänne julkaistaan mm. Geniemin tekemät WordPress-pluginit ym. julkisesti jaettavaksi tarkoitettu koodi.GogsGeniem käyttää Gogsia sisäisiin projekteihinsa. Siellä jaetaan Geniemin asiakasprojektit sekä Geniemin tekemät projektipohjat ym. sisäiseen käyttöön tarkoitettu koodi.GitlabAiemmin Geniemillä on käytetty Gitlabia. Täällä on vielä osa asiakasprojekteista ja sisäisistä projekteista. Jatkossa on tarkoitus käyttää versionhallintana jompaa kumpaa yllämainituista versionhallintajärjestelmistä.KomentoriviGeniemillä käytetään komentoriviclienttinä usein iTerm 2 -ohjelmaa Maceilla. Linux-koneilla käytetään koneen omaa terminalia. Shellinä moni käyttää ZSH:ta. Tähän suosittu lisäapu on oh-my-zsh. Osa käyttää Fish shelliä.KomentorivityökalutWP-CLI on geniemillä käytetty CLI WordPressin käsittelyyn. Tämän avulla on helppo tehdä mm. suurien kantojen exportit ja importit."
        
    } ,
  
    {
        
          "title"    : "Projektin rakenne",
          "category" : "tyokalut",
          "tags"     : "",
          "url"      : "/practices/tyokalut/rakenne/",
          "date"     : "2016-12-09 18:30:07 +0200",
          "content"  : "KansiorakenneYhtenäinen projektin kansiorakenne mahdollistaa jokaiselle kehittäjälle saman tutun aihion käyttämisen projektin aloittamiseen. Myös support ja jatkokehitys on huomattavasti helpompaa, jos kaikki kehittäjät tietävät projektista riippumatta, missä tiedostot sijaitsevat. Geniemillä on WordPress-projekteihin kaksi pohjaa: Dustpress boilerplate sekä tavallinen WordPress boilerplate.Kaikkien tulevien projektien tulee pohjautua näihin projektirakenteisiin. Alla dustpress-boilerplaten teematiedostot avattuna.|- assets/|  |- fonts/ _____________________________ # Theme fonts|  |- images/ ____________________________ # Theme images|  |- scripts/|    |- main.js __________________________ # Main JS used file to concatenate the imported scripts|    |- app.js ___________________________ # A sample JS file|  |- styles/ ____________________________ # Theme styles|    |- common/ __________________________ #|       |- _fonts.scss _____________________ # font styles|       |- _global.scss ____________________ # global styles|       |- _helper.scss ____________________ # helper styles|       |- _variables.scss _________________ # variables|       |- _wp-classes.scss ________________ # classes used by wp|    |- main.scss/ _______________________ # Main scss used to concatenate the imported styles|- dist/ _________________________________ # Concatenated and minified assets generated|  |- scripts/ ___________________________ # Dist scripts|  |- styles/ ____________________________ # Dist styles|- lang/ _________________________________ # Theme language files|- lib/ __________________________________ # Theme functions|- node_modules/ _________________________ # npm modules|- models/ _______________________________ # Dustpress models|  |- shared/ ____________________________ # Shared models|- partials/ _____________________________ # Template parts|  |- shared/ ____________________________ # Shared partials|- 404.php _______________________________ # site 404 template|- favicon.png ___________________________ # site favicon|- functions.php _________________________ # The main functions file used to import files from the lib/ folder|- index.php _____________________________ # Site index template needed by wordpress|- package.json __________________________ # package file for the npm modules|- README.md _____________________________ # theme readme|- screenshot.png ________________________ # theme screenshot for WP admin|- README.md _____________________________ # theme readme|- style.css _____________________________ # style skeleton file needed by wordpress|- webpack.config.js _____________________ # webpack config fileKolmannen osapuolen integraatiotKaikki kolmannen osapuolen integraatiot tulee olla dokumentoituna projektin juuressa INTEGRATIONS.md nimisessä tiedostossa. Integraatiot tulee dokumentoida yksi kerrallaan ja niistä tulee kertoa  kaikki oleellinen, kuten nimi, kuvaus, käyttötarkoitus, mahdolliset endpointit sekä niiden käyttö / triggeröinti lisädokumentaatioon linkkaus, jos sellainen löytyy.Esimerkki:## POF APIPartio-ohjelman rajapinta WP:n artikkeleille.### Ajastus ja toimintaKerran päivässä Wordpress kutsuu tiettyä annettua URL:ia, joka palauttaa JSONina puun artikkeleiden ID:itä, URLeja ja niiden muokkausaikoja. Kun artikkeli on muuttunut, kutsutaan sen URL:ia, josta saadaan artikkelin JSON. Tämä JSON importataan WordPressiin tehdyn PHP-importerin avulla artikkeliksi tietokantaan.### Endpointit- http://osoite.com/POF/articletree- http://osoite.com/POF/article### Lisädokumentaatio- http://osoite.com/POF/documentationAPI Keyt ja tunnuksetTunnuksia kolmannen osapuolen integraatioihin ja API:en avaimia ei tule koskaan hardkoodata projekteihin koodiin, vaan sen sijaan hallita erillisessä paikassa. Tähän paikkaan (esim. Confluence tai muu vastaava wiki) tulee tarjota osoite ja kuvaus INTEGRATIONS.md tiedostossa, jotta kaikki projektin kehittäjät tietävät mistä ne löytää.Jos API-avaimia tai muita tunnuksia on pakko käyttää projektin koodissa, tulee ne määritellä erillisessä config-tiedostossa constanteiksi, esimerkiksi WordPres-projekteissa wp-config.php-tiedostossa, tai siinä tiedostossa, josta generoidaan wp-config.&lt;?php// Määritellään vakio config-tiedostossaif ( ! defined( 'CLIENT_MANDRILL_API_KEY' ) &amp;&amp; ! ENV_DEVELOPMENT ) {    define( 'CLIENT_MANDRILL_API_KEY', '1234567890' );}Lokaalissa ympäristössä tulee aina määrittää ENV_DEVELOPMENT arvoksi true, jotta tuotantoympäristöön tarkoitettu koodi ei ajaudu vahingossa lokaalissa ympäristössä.Modulaarinen koodiJokainen koodi tulisi kirjoittaa mahdollisimman modulaariseksi ja uudelleenkäytettäväksi.Composer.jsonJokaisessa projektissa tulee olla mukana composer.json tiedosto, vaikkei siinä itsessään olisikaan Composerilla hallittuja riippuvuuksia.Every project, whether it includes Composer-managed dependencies or not, must contain a composer.json file defining the project so it can in turn be pulled in to other projects via Composer.  For example:{    \"name\": \"geniem/{project name}\",    \"type\": \"wordpress-plugin\",    \"minimum-stability\": \"dev\",    \"require-dev\": {},    \"require\": {},    \"version\": \"1.0.1\",    \"dist\": {        \"url\": \"... stable archive package URI ...\",        \"type\": \"zip\"    }}RiippuvuudetProjekteissa on kahta eri riippuvuutta ja paketinhallintaa:  npm JS ja muut assetit. Webpack ym.  Composer PHP-riippuvuudet, kuten pluginitPaketinhallinnan kautta ladattuja riippuvuuksia ei laiteta versionhallintaan mukaan, vaan niitä pidetään tallessa lokaalisti. Tällöin git-repository säilyy selkeänä ja tiiviinä."
        
    } ,
  
    {
        
          "title"    : "UX",
          "category" : "design",
          "tags"     : "",
          "url"      : "/practices/design/ux/",
          "date"     : "2016-12-09 18:27:38 +0200",
          "content"  : ""
        
    } ,
  
    {
        
          "title"    : "PHP",
          "category" : "kehitys",
          "tags"     : "",
          "url"      : "/practices/kehitys/php/",
          "date"     : "2016-12-09 17:53:35 +0200",
          "content"  : ""
        
    } ,
  
    {
        
          "title"    : "JavaScript",
          "category" : "kehitys",
          "tags"     : "",
          "url"      : "/practices/kehitys/javascript/",
          "date"     : "2016-12-09 17:53:16 +0200",
          "content"  : "SuorituskykySuorituskykyisen JavaScriptin kirjoittaminen on erittäin tärkeää. Huono ja raskas JavaScript kuormittaa käyttäjän selainta ja saattaa jopa kaataa ohjelman. Mobiiliyhteyksillä tämä korostuu erityisesti, joten JS:n toiminnallisuus ja hyvä suorituskyky täytyy pitää mielessä koko kehitysprosessin ajan.Monissa Geniemin projekteissa, kuten kaikissa WordPress-projekteissa, käytetään jQueryä. JQueryssä on monia hyviä puolia, kuten sen tarjoama AJAX-käsittely ja JS:n kääntyminen  selaimille yhtenäisellä tavalla ymmärrettäväksi koodiksi.JQueryn kanssa voi kuitenkin helposti tehdä varsin raskasta koodia. Pitää olla tarkkana, ettei esim. hae jokaista DOM-elementtiä classinsa mukaan monta kertaa uudestaan saman koodin aikana, vaan huolehtii elementtien ajonaikaisesta cachetuksesta ja oikeaoppisesta DOM:in käsittelystä.Käytä jQueryä harkitenMonissa tapauksissa jQueryn käyttö elementtien manipulointiin voi olla turhaa. Alla esimerkki, jossa elementin piilottamisen voi hoitaa vain JavaScriptillä, mikä on tehokkaampaa.document.getElementById( 'element' ).style.display = 'none';vs.jQuery( '#element' ).hide();Elementin asetus jQuery-objektiksiKun jqueryllä haetaan DOMista elementti, tekee se siitä taustalla jQuery-objektinjQuery( '#menu' );Vaihtoehtoisesti jQuerylle voi antaa manuaalisesti kokoelman elementtejä tai elementin vastaavanlaisen jQuery-objektin luomiseksi. Tämä on suorituskyvyllisesti nopeampaa.// Elementti haetaan ID:lläjQuery( document.getElementById( 'menu' ) );// Elementti haetaan käyttäen \"querySelector\"-metodia// Classeille hyvä, joskin classien avulla EI kannata hakea elementtejä, jos ei ole pakko.document.querySelector('#menu');document.querySelectorAll('.menu-item');DOMin cachetusapp.$element = jQuery( '#element' );// Muuta koodia...app.$element.addClass('element--state');app.$element.children('#child-element');// DOM node on cachessa, joten sitä ei haeta uusiksi joka kertaJS-malliGeniem käyttää javascript-tiedostojensa koodin jäsentämiseen alla olevaa mallia. Ideana mallissa on se, että yhden sivun JS on yhden olion sisällä metodeina, ja olio palautetaan myös window:n alle. Täten voidaan helposti cachettaa olion käyttämät DOM-elementit ja hallita olion metodeja järjestelmällisesti.Malli on kommentoitu ja se sisältää muutaman hyödyllisen esimerkin. Mallin koodi on projektien boilerplatejen JS-puolella valmiina.// Luodaan olio ja annetaan sille parametreinä käyttöön window, document ja jQuery. jQuery on mapatty dollarimerkkiin oletuksena.window.SivunOlio = ( function( window, document, $ ){    // Viittaus olioon sisäisesti.    var app = {};    // Olion muuttujien cachetusfunktio. DOM-elementit haetaan olion käyttöön ajonaikaiseen cacheen.    app.cache = function(){        // Muuttuja prefixataan dollarimerkillä, jotta tiedetään, että se on jQuery-objekti.        app.$element            = $('#element').data('ajaxurl');        // Muuttujiin voi asettaa mitä vain dataa.        app.elementData         = $('#element').data('ajaxurl');        app.boolean             = false;    };    // Olion init-metodi. Asetetaan funktio muuttujaan, mikä on suorituskykyisempää, kuin irtonaiset funktion deklaraatiot.    app.init = function(){        // Kutsutaan cachetusmetodia        app.cache();        // Kutsutaan olion metodia        app.method1();        // Asetetaan event handler cachetetulle elementille. Esimerkissä mukana parametrien välitys handler-metodille.        app.element.on( 'click', { passedParameter: \"value\" }, app.method2 );    };    // Metodin koodi    app.method1 = function () {        // Koodia...    };    // Eventhandler -metodin koodi. Esimerkkinä event datan lisäksi metodin saama parametri    app.method2 = function( e, functionParam1 ){        e.preventDefault();        e.stopPropagation();        // Annettu event data muuttujaan.        var param1 = e.data.passedParameter;        // Annettu parametri muuttujaan.        var param2 = functionParam1;        // Koodia...    };    // Ajetaan olion init-metodi document readyssä.    $(document).ready(function() {        app.init();    });    // Palautetaan olio window:lle. Olioon viitataan muualla käyttäen: \"window.SivunOlio\".    return app;})( window, document, jQuery );Koodin kommentointiKoodin kommentointi on yksi tärkeimmistä käytännöistä ylläpidettävyyden ja jatkokehitettävyyden kannalta. Kommentoimalla koodiasi kattavasti ja yksiselitteisesti varmistat, että toisetkin ymmärtävät mitä olet kirjoittanut. Kirjoita kommentteja koodiin mieluummin liikaa kuin liian vähän.KoodaustyylitGeniemin JavaScript-koodaustyylejä valvotaan Geniemin JSCS-konfiguraatiolla. Konfiguraatiotiedostoa käytetään Sublime Linterissä, jolloin koodaustyylivirheet näkee heti koodia kirjoittaessa. Katso ohjeet työkalut-sivulta. Alla muutama poiminta linterin pakottamista säännöistä.  Muuttujien ja metodien nimeämisessä käytetään camelCasea.  Olioiden ja niiden metodien sekä muuttujien nimeäminen tulee olla kuvaavaa ja tarpeeksi tarkkaa.  Rivinvaihtoja käytetään siten, että koodi on selkeästi jäsenneltyä.  Välilyöntejä käytetään runsaasti, esim. metodin parametrien ja sulkujen välillä sekä if-ehtolausekkeissa."
        
    } ,
  
    {
        
          "title"    : "CSS",
          "category" : "kehitys",
          "tags"     : "",
          "url"      : "/practices/kehitys/css/",
          "date"     : "2016-12-09 17:45:09 +0200",
          "content"  : "YhdenmukaisuusYhdenmukaisesti rakennettujen ja jäsenneltyjen tyylien lukeminen, kirjoittaminen ja ylläpitäminen on ehdottoman tärkeää projekteissa, joissa on monia tyylien kirjoittajia. Siksi Geniemillä pidetään huolta siitä, että tyylitiedostomme tehdään tietyllä tapaa projekteista riippumatta.SyntaksiGeniemillä käytetään sass-linteriä, joka tarkistaa tehdyt tyylitiedostot Geniemin määrittelemää säännöstöä vasten. Alle on avattu oleellisia seikkoja syntaksisäännöistä.  Joka selektori omalle rivilleen  Joka määrittely omalle rivilleen  Loppusulku omalle rivilleenEi näin:.class-1, .class-2,.class-3 {width: 10px; height: 20px;color: red; background-color: blue; }Näin:.class-1,.class-2,.class-3 {  width: 10px;  height: 20px;  color: red;  background-color: blue;}  Avaussulkua ennen oltava väli  Määritelmän ja sen arvon väliin tultava yksi välilyönti  Pilkulla eroteltujen arvojen väliin tultava yksi välilyöntiEi näin:.class-1,.class-2{  width:10px;  box-shadow:0 1px 5px #000,1px 2px 5px #ccc;}Näin:.class-1,.class-2 {  width: 10px;  box-shadow: 0 1px 5px #000, 1px 2px 5px #ccc;}  Kirjoita kaikki arvot pienellä  Nolla-arvoille ei tarvitse kirjoittaa yksiköitä  Kaikki määrittelyt on päätettävä puolipilkulla  Käytä tuplahipsujaEi näin:section {  background-color: #FFFFFF;  font-family: 'Times New Roman', serif;  margin: 0px}Näin:section {  background-color: #fff;  font-family: \"Times New Roman\", serif;  margin: 0;}Jos määrittelyyn ei tarvitse asettaa kaikkia sen arvoja, älä käytä shorthandejaEi näin:.header-background {  background: blue;  margin: 0 0 0 10px;}Näin:.header-background {  background-color: blue;  margin-left: 10px;}Määrittelyjen järjestysMäärittelyt tulee ryhmitellä tyyppinsä mukaan järjestykseen, jotta niitä on helppo käydä läpi. Järjestys on seuraava:* Positioning* Box model* Typografia* VisuaalitSass-järjestys:  @extendit  Tavalliset tyylimäärittelyt ( mahdollisuus yliajaa extendit )  @includet ( mixinit ja placeholderit eri kohdissa )  Media queryt  Nestatut selektoritSASSGeniemillä käytetään tyylitiedostojen kirjoittamiseen SCSS-syntaksia. Projektirakenteesta riippuen ylläpidämme yhtä main.scss -tiedostoa, johon importataan loput .scss -päätteiset tiedostot. Itse kirjoittamamme import-tiedostot luodaan sopiviin kansioihin projektin rakenteessa ja ne nimetään käyttäen alaviivaa tiedostonimen alussa.Käytä mixineitä ja placeholdereitaToistuvan koodin tai abstraktoitujen määrittelyryhmien käyttäminen monessa eri kohdassa toteutetaan placeholdereiden tai mixinien avulla. Funktionaalisen luonteensa takia ne rajaavat tyylien kirjoittamisen ja virheiden määrää sekä helpottavat ylläpitoa.Käytä mixineitä, kun tahdot enemmän funktionaalisuutta ja mahdollisuuden antaa funktioille muuttujia. Käytä placeholdereita, kun tahdot määritellä toistuvia tyyliblokkeja eri elementeille. Älä extendaa oikeita luokkia, vaan käytä aina placeholder-luokkia niiden sijaan.NestaaminenMuista käyttää nestaamista harkiten. Liika nestaaminen aiheuttaa turhaa spesifisyyttä tyyliin. Tällöin myös elementtien tyylien ylikirjoittaminen vaatii samantasoista spesifisyyttä.Nestaamista käytetään seuraavissa tilanteissa koodin selkeyttämiseksi.  pseudo-luokat  pseudo-elementit  komponenttien tilat ja modifikaatiot (BEM)  media querytNimeäminenSelektorit tulee nimetä pikkukirjaimilla ja sanat tulee erottaa toisistaan väliviivoilla. Camelcaseja tai alaviivoja ei suositella. Alaviivat ovat hyväksyttyjä BEM-nimeämiskäytäntöä hyödynnettäessä (BEM). Kuten BEM:issäkin, yleisesti muuttujat tulee nimetä yhdenmukaisesti, selkeästi ja semanttisesti.Ei näin:.btnRed {    background-color: red;}Näin:.btn-warning {    background-color: red;}Jos CSS-luokan nimi on liian geneerinen, se saattaa olla ristiriidassa jonkin toisen komponentin, pluginin tai kolmannen osapuolen kirjaston tyylimäärittelyn kanssa. Tällaisissa tapauksissa käytäntönä on kirjoittaa kuitenkin web-projektin tyylit geneerisenä ja luottaa siihen, että pienempien komponenttien tai kirjastojen tyylit on prefiksattu.Tunnetusti ad-blokattujen CSS-luokkien käyttöä tulee välttää. Listan tällaisista luokkanimistä voi tarkistaa täältä.DokumentaatioTyylipuolellakin koodin dokumentointi on yhtä tärkeää. Se selkeyttää lukemista ja pysäyttää ajattelemaan juuri tehtyä koodia. Jos selitys on liian monimutkainen, myös koodikin saattaa olla.KommentointiGeniemillä noudatetaans tyyleissä seuraavia kommentointistandardeja. Kommenteissa kannattaa olla mahdollisimman yksiselitteinen ja selkeä. Kommentoi mieluummin liikaa kuin liian vähän. Käytä kommenttiblokkeja selittämään tyylipartialin osioita ja inline-kommentteja lyhyempiin kuvauksiin. Kommentoi englanniksi./** * Section title * * Description of section */Muista kommentoida myös monimutkaisemmat tyylimäärittelyt mahdollisimman selkeästi./* Select list item 4 to 8, included */li:nth-child(n+4):nth-child(-n+8) {    color: red;}"
        
    } ,
  
    {
        
          "title"    : "HTML",
          "category" : "kehitys",
          "tags"     : "",
          "url"      : "/practices/kehitys/html/",
          "date"     : "2016-12-09 17:36:34 +0200",
          "content"  : "Geniemillä tavoitteena on kirjoittaa tuoretta ja selkeää HTML-merkkausta. Käytämme uusimpien määritysten mukaista merkkausta tinkimättä tarvittavasta selainyhteensopivuudesta. Merkkauksen määrä tulee olla mahdollisimman pieni, jotta luettavuus ja selkeys säilyy.Merkkauksen tulee olla validia HTML:ää, ja sitä voi testata W3C validator-työkalulla. Merkkauksen tulee olla jäsennelty luettavaksi ja esim. php-koodi dokumenteissa tulee olla sisennetty selkeästi.Selkeä jäsentely merkkaukselle:&lt;ul&gt;    &lt;?php foreach( $things as $thing ) : ?&gt;        &lt;li&gt;&lt;?php echo esc_html( $thing ); ?&gt;&lt;/li&gt;    &lt;?php endforeach; ?&gt;&lt;/ul&gt;DoctypeKaikki web-projektit määritellään käyttämään seuraavaa doctypeä: &lt;!DOCTYPE html&gt;MerkistökoodausKaikki web-projektit määritellään käyttämään UTF-8 -merkistökoodausta. Dokumentin alkuun kirjoitetaan tagi &lt;meta charset=“utf-8”&gt;SemanttisuusMerkkauksen tulee olla semanttista ja turhia divejä pitää välttää. Pitää pyrkiä käyttämään esim &lt;header&gt; tageja pelkän tavallisen &lt;div&gt;tagien sijasta oikeissa paikoissa. Merkkauksen tulee selkeyttää dokumenttia sen lukijalle ja monen kehittäjän yhteistyössä sen selkeys on ehdottoman tärkeää.Esimerkki semanttisesta HTML-merkkauksesta:&lt;div class=\"wrapper\"&gt;    &lt;header&gt;        &lt;h1&gt;My super duper page&lt;/h1&gt;        &lt;!-- Header content --&gt;    &lt;/header&gt;    &lt;main role=\"main\"&gt;        &lt;!-- Page content --&gt;    &lt;/main&gt;    &lt;aside role=\"complementary\"&gt;        &lt;!-- Secondary content --&gt;    &lt;/aside&gt;&lt;/div&gt;BEMHTML-elementtien luokat tulee nimetä BEM-käytäntöjen mukaisesti. Nimeämiskäytäntö on suosittu sekä toimiva ja sen avulla saadaan luotua selkeitä, yksiselitteisiä ja tarkoituksellisia luokkia elementeille. Luokkien nimeämiskäytännöistä lisää CSS-osiossa.Lisää elementeille ID:t JavaScriptiä vartenID:iden käyttöä kannattaa normaalisti välttää CSS:ssä liian spesifisyyden poistamiseksi ja siksi niitä ei myöskään usein tarvitse kirjoittaa merkkaukseen. Tähän on kuitenkin poikkeuksia, esim. ankkurilinkit tai lomakkeiden inputit. Jos kuitenkin on oikea käyttötarkoitus, voi elementeille antaa JavaScriptiä varten ID:t. Nämä ID:t ovat samannimisiä, kuin elementin määrittävä luokka, mutta eteen laitetaan js-. Tällöin javascriptissä voidaan tallentaa elementti muuttujaan sen ID:n avulla, mikä on tehokkaampaa ja nopeampaa.  &lt;!-- Artikkeli voidaan napata javascriptissä kiinni ID:nsä avulla. --&gt;  &lt;article id=\"js-article--blog\" class=\"article--blog\"&gt;    &lt;header id=\"js-article__header\" class=\"article__header\"&gt;    &lt;/header&gt;  &lt;/article&gt;HTML5 mukaiset resurssitUuden merkkausspeksin mukaisesti enää ei tarvitse erikseen mainita, tyyli- ja scriptitiedostojen tyyppejä. Nämä siis jätetään kokonaan pois. Jos lisäät resurssit wordpressin kautta, huolehtii se tästä puolestasi.Ei näin:&lt;link type=\"text/css\" rel=\"stylesheet\" href=\"css/style.css\" /&gt;&lt;script type=\"text/javascript\" src=\"script/scripts.js\"&gt;&lt;/script&gt;Näin:&lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;&lt;script src=\"script/scripts.js\"&gt;&lt;/script&gt;Inline-tyylit ja -scriptit.Inline-tyylien ja javascriptien käyttöä ei suositella, sillä se ei ole ylläpidettävää koodia.Progressive enhancementGeniemillä suunnitellaan web-projektit käyttäen progressive enhancement -menetelmiä. Tämä tarkoittaa, että sivut suunnitellaan siten, että minimitasolla on ehjä ja selkeä perustason palvelu, johon rakennetaan päälle featureita + ominaisuuksia selainten niitä tukiessa.Hyvä esimerkki tästä on vaikkapa PNG:n käyttö sivuston logossa vaihtaen selaintuen salliessa SVG:n sen tilalle.Nettipalvelut rakennetaan siis alusta loppuun lisäten tarvittaessa featureita, eikä toisin päin. Alkutasot määräytyvät projektikohtaisesti riippuen esim. sopimuksissa määritellystä selaintuesta ja projektin luonteesta.PolyfillitJos projektissa käytetään tekniikoita, joita ei ole täysin tuettu kaikilla selaimilla, mutta kokemuksen pitää silti olla sama ko. featuren kohdalla, voidaan käyttää polyfillejä tuomaan sama kokemus näille selaimille / laitteille.ModernizrKäytämme selaintuen ja featureiden testaamiseen Modernizr-kirjastoa. Modernizr tulee asentaa joko NPM:n kautta tai erillisenä js-kirjastona, joka lisätään projektin kirjastojen yhdistävään js-tiedostoon.MikroformaatitKun mahdollista, Geniemillä pyritään käyttämään HTML-merkkauksen jäsentämiseen mikroformaatteja. Nämä ovat standardoituja HTML-elementtien tarkentavia nimeämisiä ja rakenteita, jotka vaikuttavat positiivisesti SEO:on ja yhtenäistävät formaatteja eri nettipalveluiden kesken. Esimerkki mikroformaattien käytöstä on vaikkapa sivustolla olevan ravintolan tietokortti, tai henkilön yhteystiedot.Formaatit löytyvät sivustolta Schema.org ja niiden avulla rakennetun merkkauksen voi testata käyttämällä Google Structured Data Testing Tool-työkalua.Alla esimerkki kirja-arvostelu -mikroformaatista.&lt;div itemscope itemtype=\"http://schema.org/Review\"&gt;  &lt;div itemprop=\"itemReviewed\" itemscope itemtype=\"http://schema.org/Book\"&gt;    &lt;span itemprop=\"name\"&gt;The Catcher in the Rye&lt;/span&gt; (    &lt;a itemprop=\"sameAs\" href=\"http://en.wikipedia.org/wiki/The_Catcher_in_the_Rye\"&gt;wikipedia&lt;/a&gt;)  &lt;/div&gt;  &lt;span itemprop=\"reviewRating\" itemscope itemtype=\"http://schema.org/Rating\"&gt;    &lt;span itemprop=\"ratingValue\"&gt;4&lt;/span&gt;  &lt;/span&gt; stars -  &lt;strong&gt;\"&lt;span itemprop=\"name\"&gt;A good read.&lt;/span&gt;\"&lt;/strong&gt;  &lt;span itemprop=\"author\" itemscope itemtype=\"http://schema.org/Person\"&gt;    &lt;span itemprop=\"name\"&gt;Bob Smith&lt;/span&gt;  &lt;/span&gt;  &lt;span itemprop=\"reviewBody\"&gt;Catcher in the Rye is a fun book. It's a good book to read.&lt;/span&gt;&lt;/div&gt;SEOMikroformaattien lisäksi Geniemillä huolehditaan SEO:sta kirjoittamalla semanttista, selkeää ja rooleilla täydennettyä HTML-merkkausta. Otsikoiden tasot ja järjestykset suunnitellaan selkeiksi kokonaisuuksiksi ja pidetään yleisesti huolta siitä, että HTML tukee dokumentin luettavuutta ja hakukonenäkyvyyttä. WordPress-projekteissa käytetään joko kolmannen osapuolen SEO-lisäosia tai huolehditaan tarvittavat metatiedot sivustojen sivujen headereihin itse.EsteettömyysNettipalveluiden saavutettavuus esteettömästi on kasvava trendi ja usein myös tärkeä edellytys palvelun kehittämiselle. Geniemillä pyritään tekemään sivustoista saavutettavia myös käyttäjille, jotka käyttävät netin selaamiseen screen readereita tai vastaavia apuvälineitä.Geniemillä lisätään merkkaukseen ARIA-roolit, tehdään semanttista merkkausta, suunnitellaan sivujen otsikoinnit ja hyödynnetään kuvien alt-tekstejä tuomaan palveluista saavutettavat kaikille.Geniemillä seurataan seuraavien artikkeleiden mukaista ARIA-roolien käyttöä ja hyväksi todettuja menetelmiä.  MDN ARIA accessibility  WCAG (Web Content Accessibility Guidelines)ARIA-roolitARIA on W3C kehittämä standardi esteettömyydelle ja sillä tuodaan HTML-merkkauksen päälle kuvaa konteksti. ARIA-roolit eivät vaikuta merkkaukseen näkyvästi, vaan palvelevat screen readereita ja täten myös auttavat SEO:ssa. Alla esimerkki roolien käytöstä:&lt;header id=\"js-masthead\" class=\"site-header\" role=\"banner\"&gt;&lt;/header&gt;ARIA statetARIA:n avulla voidaan myös kuvata elementtien tiloja, kuten esim. välilehtien aktiivisuutta ja niiden selaamista. ARIA stateja voidaan lisätä suoraan merkkaukseen sekä JavaScriptillä, jolloin nettisivujen esteetön toiminnallisuus säilyy myös niitä selattaessa. Alla esimerkki välilehdistä:&lt;ul role=\"tabs\"&gt;    &lt;li&gt;        &lt;a href=\"#js-first-tab\" role=\"tab\" aria-active=\"true\"&gt;Panel 1&lt;/a&gt;        &lt;!-- Välilehden 1 sisältö --&gt;    &lt;/li&gt;    &lt;li&gt;        &lt;a href=\"#js-second-tab\" role=\"tab\" aria-active=\"false\" aria-controls=\"second-tab\"&gt;Panel 2&lt;/a&gt;        &lt;!-- Välilehden 2 sisältö --&gt;    &lt;/li&gt;&lt;/ul&gt;Lomakkeiden esteettömyysYksi useasti sivuutettu ominaisuus nettipalveluissa on lomakkeiden esteettömyys. HTML5 tarjoaa lomakkeisiin kuitenkin muutaman standardoidun tavan saada niistä saavutettavat kaikille.      Jokaisella lomakkeen kentällä tulee olla oma label tagi, joka sisältää myös for attribuutin, jossa kerrotaan, että kyseinen label kuuluu tietylle kentälle.        Lomakkeiden kentät tulee myös jäsentää loogisesti fieldset -elementtien avulla.        Lomakkeiden kenttien järjestys liikuttaessa näppäimistön (tabin) avulla tulee olla looginen ja seurata elementtien luonnollista järjestystä merkkauksessa. Tarvittaessa jokin elementti, kuten modaalit, voidaan tiputtaa pois selattavien elementtien kokoelmasta käyttäen tabindex=-1 attribuuttia.  "
        
    } 
  
  ,
  
   {
     
   } ,
  
   {
     
        "title"    : "Johdanto",
        "category" : "front-page",
        "tags"     : "",
        "url"      : "/practices/",
        "date"     : "",
        "content"  : "Tämä ohjesivusto on tarkoitettu sekä uusille ohjelmistokehittäjille ohjenuoraksi että asiakkaille dokumentaatioksi Geniem Oy:n sisäisesti kehitetyistä hyvistä toimintatavoista. Sivustolta löytyy web-ohjelmistokehityksen tärkeimpien osa-alueiden ohjeet."
     
   } ,
  
   {
     
   } ,
  
   {
     
   } ,
  
   {
     
   } 
  
]
